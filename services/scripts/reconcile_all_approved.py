#!/usr/bin/env python3
"""
WO-2026-0206-014: approved í•­ëª© ì „ì²´ ì •í•©ì„± ë³µêµ¬

ì‘ì—… íƒœê·¸: reconciled_wo014_full_approved_fix

ì‹¤í–‰:
    python reconcile_all_approved.py --scan        # ìŠ¤ìº”ë§Œ (í˜„í™© íŒŒì•…)
    python reconcile_all_approved.py --dry-run     # í…ŒìŠ¤íŠ¸ ëª¨ë“œ
    python reconcile_all_approved.py               # ì‹¤ì œ ì‹¤í–‰
"""

import os
import sys
import json
from pathlib import Path
from datetime import datetime

PROJECT_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

import gspread
from google.oauth2.service_account import Credentials

# Cloudinary ì„¤ì •
try:
    import cloudinary
    import cloudinary.uploader
    from dotenv import load_dotenv
    load_dotenv(PROJECT_ROOT / ".env")

    cloudinary.config(
        cloud_name=os.getenv("CLOUDINARY_CLOUD_NAME"),
        api_key=os.getenv("CLOUDINARY_API_KEY"),
        api_secret=os.getenv("CLOUDINARY_API_SECRET")
    )
    CLOUDINARY_AVAILABLE = True
except ImportError:
    CLOUDINARY_AVAILABLE = False

# ì—´ ì¸ë±ìŠ¤ (1-based)
COL_NUM = 1
COL_ENG_NAME = 2
COL_KR_NAME = 3
COL_SAFETY = 5        # Eì—´: ì•ˆì „ë„
COL_STATUS = 6        # Fì—´: ê²Œì‹œìƒíƒœ
COL_CAPTION_INSTA = 16   # Pì—´
COL_CAPTION_THREADS = 17  # Qì—´
COL_METADATA = 18     # Rì—´
COL_CLOUDINARY = 19   # Sì—´
COL_FOLDER_STATUS = 21  # Uì—´

# ì•ˆì „ë„ ì •ì˜
SAFETY_LEVELS = {
    'SAFE': ['boiled_egg', 'spinach', 'chicken', 'chicken_breast', 'rice', 'cucumber',
             'carrot', 'sweet_potato', 'apple', 'banana', 'watermelon', 'blueberry',
             'pumpkin', 'broccoli', 'lettuce', 'peas', 'green_beans', 'cabbage',
             'asparagus', 'beet', 'tofu', 'white_fish', 'duck', 'turkey'],
    'CAUTION': ['shrimp', 'potato', 'nuts', 'almonds', 'cheese', 'yogurt', 'milk',
                'egg', 'peanut', 'soy', 'wheat', 'corn', 'mushroom', 'toast',
                'baguette', 'sandwich', 'croissant', 'muffin', 'pancake', 'waffle',
                'cereal', 'granola', 'bacon', 'meatball', 'chicken_skewer',
                'dakgangjeong', 'bulgogi', 'kimbap', 'bibimbap', 'udon', 'kalguksu',
                'naengmyeon', 'tteokguk', 'kimchi', 'quail_egg', 'mackerel',
                'melon', 'plum', 'pomegranate', 'raspberry', 'blackberry', 'coconut',
                'lemon', 'bean_sprouts', 'poached_egg', 'raisin', 'perrier'],
    'DANGER': ['cheetos', 'doritos', 'lays', 'ritz', 'pizza', 'ramen', 'cake',
               'brownie', 'ice_cream', 'candy', 'cookie', 'fanta', 'sprite',
               'coca_cola', 'milkis', 'banana_milk', 'reeses', 'skittles',
               'starburst', 'jjajangmyeon', 'donut', 'soju'],
    'FORBIDDEN': ['onion', 'garlic', 'grape', 'chocolate', 'xylitol', 'avocado',
                  'macadamia', 'alcohol', 'coffee', 'tea']
}


def get_safety_level(eng_name: str) -> str:
    """ì˜ë¬¸ëª…ìœ¼ë¡œ ì•ˆì „ë„ ê²°ì •"""
    eng_lower = eng_name.lower()
    for level, foods in SAFETY_LEVELS.items():
        if eng_lower in [f.lower() for f in foods]:
            return level
    return 'CAUTION'  # ê¸°ë³¸ê°’


def get_sheet():
    """êµ¬ê¸€ì‹œíŠ¸ ì—°ê²°"""
    scopes = [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive"
    ]
    creds_path = PROJECT_ROOT / "config" / "google-credentials.json"
    creds = Credentials.from_service_account_file(str(creds_path), scopes=scopes)
    client = gspread.authorize(creds)
    return client.open("Sunshine").worksheet("ê²Œì‹œì½˜í…ì¸ ")


def get_approved_folder(num: str) -> Path:
    """ë²ˆí˜¸ë¡œ 3_approved í´ë” ì°¾ê¸°"""
    approved_dir = PROJECT_ROOT / "contents" / "3_approved"
    for folder in approved_dir.iterdir():
        if folder.is_dir() and folder.name.startswith(f"{num}_"):
            return folder
    return None


def generate_caption_instagram(food_kr: str, food_en: str, safety: str) -> str:
    """ì¸ìŠ¤íƒ€ê·¸ë¨ ìº¡ì…˜ ìƒì„±"""
    safety_msg = {
        'SAFE': f"ğŸŸ¢ {food_kr}, ê°•ì•„ì§€ê°€ ë¨¹ì–´ë„ ì•ˆì „í•´ìš”!",
        'CAUTION': f"ğŸŸ¡ {food_kr}, ì†ŒëŸ‰ë§Œ ê¸‰ì—¬í•˜ì„¸ìš”!",
        'DANGER': f"ğŸ”´ {food_kr}, ê¸‰ì—¬ë¥¼ ê¶Œì¥í•˜ì§€ ì•Šì•„ìš”!",
        'FORBIDDEN': f"â›” {food_kr}, ì ˆëŒ€ ê¸‰ì—¬ ê¸ˆì§€!"
    }

    caption = f"""ğŸ• ê°•ì•„ì§€ {food_kr} ë¨¹ì–´ë„ ë ê¹Œìš”?

{safety_msg.get(safety, safety_msg['CAUTION'])}

ìì„¸í•œ ë‚´ìš©ì€ ìŠ¬ë¼ì´ë“œë¥¼ í™•ì¸í•˜ì„¸ìš” ğŸ‘‰

ğŸ’¾ ì €ì¥í•´ë‘ê³  í•„ìš”í•  ë•Œ í™•ì¸í•˜ì„¸ìš”!
ğŸ’¬ ê¶ê¸ˆí•œ ìŒì‹ì´ ìˆë‹¤ë©´ ëŒ“ê¸€ë¡œ ì•Œë ¤ì£¼ì„¸ìš”!

#ê°•ì•„ì§€ìŒì‹ #ë°˜ë ¤ê²¬ #ê°•ì•„ì§€ê°„ì‹ #í«í‘¸ë“œ #sunshinedogfood

â„¹ï¸ ì¼ë¶€ ì´ë¯¸ì§€ëŠ” AIë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
â„¹ï¸ Some images were generated by AI."""

    return caption


def generate_caption_threads(food_kr: str, food_en: str, safety: str) -> str:
    """ì“°ë ˆë“œ ìº¡ì…˜ ìƒì„±"""
    safety_emoji = {'SAFE': 'ğŸŸ¢', 'CAUTION': 'ğŸŸ¡', 'DANGER': 'ğŸ”´', 'FORBIDDEN': 'â›”'}

    caption = f"""{safety_emoji.get(safety, 'ğŸŸ¡')} ê°•ì•„ì§€ {food_kr} ë¨¹ì–´ë„ ë ê¹Œìš”?

ìì„¸í•œ ë‚´ìš©ì€ ì¸ìŠ¤íƒ€ê·¸ë¨ì—ì„œ í™•ì¸í•˜ì„¸ìš”!
@sunshinedogfood

#ê°•ì•„ì§€ìŒì‹ #ë°˜ë ¤ê²¬"""

    return caption


def ensure_metadata(folder: Path, eng_name: str, kr_name: str, safety: str, dry_run=False) -> dict:
    """ë©”íƒ€ë°ì´í„° í™•ì¸/ìƒì„±/ë³´ì™„"""
    metadata_path = folder / "metadata.json"

    if metadata_path.exists():
        with open(metadata_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    else:
        data = {}

    changes = []

    # í•„ìˆ˜ í•­ëª© ë³´ì™„
    if not data.get('food_name_en'):
        data['food_name_en'] = eng_name
        changes.append(f"food_name_en: {eng_name}")

    if not data.get('food_name_kr'):
        data['food_name_kr'] = kr_name
        changes.append(f"food_name_kr: {kr_name}")

    if not data.get('safety_level'):
        data['safety_level'] = safety
        changes.append(f"safety_level: {safety}")
    elif data.get('safety_level', '').upper() != safety:
        old = data.get('safety_level')
        data['safety_level'] = safety
        changes.append(f"safety_level: {old} â†’ {safety}")

    if data.get('status') != 'approved':
        old = data.get('status', 'unknown')
        data['status'] = 'approved'
        changes.append(f"status: {old} â†’ approved")

    # ì •í•©ì„± ë³µêµ¬ íƒœê·¸
    data['reconcile_tag'] = 'reconciled_wo014_full_approved_fix'
    data['reconciled_at'] = datetime.now().isoformat()

    if changes and not dry_run:
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    return {'changes': changes, 'path': str(metadata_path)}


def ensure_captions(folder: Path, eng_name: str, kr_name: str, safety: str, dry_run=False) -> dict:
    """ìº¡ì…˜ íŒŒì¼ í™•ì¸/ìƒì„±"""
    result = {'instagram': False, 'threads': False, 'created': []}

    insta_path = folder / "caption_instagram.txt"
    threads_path = folder / "caption_threads.txt"

    if not insta_path.exists():
        caption = generate_caption_instagram(kr_name, eng_name, safety)
        if not dry_run:
            with open(insta_path, 'w', encoding='utf-8') as f:
                f.write(caption)
        result['created'].append('caption_instagram.txt')
    result['instagram'] = True

    if not threads_path.exists():
        caption = generate_caption_threads(kr_name, eng_name, safety)
        if not dry_run:
            with open(threads_path, 'w', encoding='utf-8') as f:
                f.write(caption)
        result['created'].append('caption_threads.txt')
    result['threads'] = True

    return result


def upload_to_cloudinary(folder: Path, num: str, eng_name: str, dry_run=False) -> dict:
    """Cloudinary ì—…ë¡œë“œ"""
    if not CLOUDINARY_AVAILABLE:
        return {'success': False, 'error': 'cloudinary not available'}

    images = []
    for i in range(7):
        pattern = f"*_{i:02d}.png"
        matches = list(folder.glob(pattern))
        if matches:
            images.append(matches[0])

    if not images:
        return {'success': False, 'error': 'no images found'}

    results = []
    errors = []

    for img_path in images:
        public_id = f"sunshine/{num}_{eng_name}/{img_path.stem}"

        if dry_run:
            results.append({'file': img_path.name, 'public_id': public_id})
            continue

        try:
            result = cloudinary.uploader.upload(
                str(img_path),
                public_id=public_id,
                overwrite=True,
                resource_type="image"
            )
            results.append({
                'file': img_path.name,
                'public_id': public_id,
                'url': result.get('secure_url')
            })
        except Exception as e:
            errors.append(f"{img_path.name}: {str(e)}")

    if errors:
        return {'success': False, 'error': '; '.join(errors), 'uploaded': results}

    return {'success': True, 'uploaded': results, 'count': len(results)}


def reconcile_all(dry_run=False, scan_only=False):
    """ì „ì²´ approved í•­ëª© ì •í•©ì„± ë³µêµ¬"""
    print("=" * 70)
    print(f"ğŸ”§ WO-2026-0206-014: approved í•­ëª© ì „ì²´ ì •í•©ì„± ë³µêµ¬")
    print(f"   íƒœê·¸: reconciled_wo014_full_approved_fix")
    print(f"   ì‹œê°: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    if scan_only:
        print("   ëª¨ë“œ: ìŠ¤ìº”ë§Œ (í˜„í™© íŒŒì•…)")
    elif dry_run:
        print("   ëª¨ë“œ: dry-run (í…ŒìŠ¤íŠ¸)")
    print("=" * 70)

    sheet = get_sheet()
    all_data = sheet.get_all_values()

    # approved + P/Q/R/S ë¯¸ì™„ë£Œ í•­ëª© ì°¾ê¸°
    incomplete = []
    for idx, row in enumerate(all_data[1:], start=2):
        if len(row) < COL_CLOUDINARY:
            continue

        num = row[COL_NUM - 1]
        eng = row[COL_ENG_NAME - 1]
        kr = row[COL_KR_NAME - 1] if len(row) >= COL_KR_NAME else ""
        status = row[COL_STATUS - 1]
        safety = row[COL_SAFETY - 1] if len(row) >= COL_SAFETY else ""
        p = row[COL_CAPTION_INSTA - 1] if len(row) >= COL_CAPTION_INSTA else ""
        q = row[COL_CAPTION_THREADS - 1] if len(row) >= COL_CAPTION_THREADS else ""
        r = row[COL_METADATA - 1] if len(row) >= COL_METADATA else ""
        s = row[COL_CLOUDINARY - 1] if len(row) >= COL_CLOUDINARY else ""

        if status == 'approved':
            needs_fix = (p in ['-', ''] or q in ['-', ''] or
                        r in ['-', ''] or s in ['-', ''])
            if needs_fix:
                incomplete.append({
                    'idx': idx,
                    'num': num,
                    'eng': eng,
                    'kr': kr,
                    'safety': safety,
                    'p': p, 'q': q, 'r': r, 's': s
                })

    print(f"\nğŸ“Š ìŠ¤ìº” ê²°ê³¼: {len(incomplete)}ê±´ ì •í•©ì„± ë³µêµ¬ í•„ìš”")

    if scan_only:
        print("\në²ˆí˜¸ | ì˜ë¬¸ëª… | P | Q | R | S")
        print("-" * 60)
        for item in incomplete[:20]:
            print(f"{item['num']} | {item['eng'][:15]:15} | {item['p']:4} | {item['q']:4} | {item['r']:4} | {item['s']:4}")
        if len(incomplete) > 20:
            print(f"... ì™¸ {len(incomplete) - 20}ê±´")
        return

    # ë³µêµ¬ ì‹¤í–‰
    updates = []
    stats = {
        'caption_created': 0,
        'metadata_fixed': 0,
        'cloudinary_uploaded': 0,
        'errors': []
    }

    for item in incomplete:
        num = item['num']
        eng = item['eng']
        kr = item['kr'] or eng  # í•œê¸€ëª… ì—†ìœ¼ë©´ ì˜ë¬¸ëª… ì‚¬ìš©

        print(f"\n{'â”€'*60}")
        print(f"[{num}] {eng} ({kr})")

        folder = get_approved_folder(num)
        if not folder:
            print(f"  âš ï¸ í´ë” ì—†ìŒ - ê±´ë„ˆëœ€")
            stats['errors'].append(f"{num}: folder not found")
            continue

        # ì•ˆì „ë„ ê²°ì •
        safety = get_safety_level(eng)
        print(f"  ì•ˆì „ë„: {safety}")

        # 1. ë©”íƒ€ë°ì´í„°
        if item['r'] in ['-', '']:
            print(f"  ğŸ“ ë©”íƒ€ë°ì´í„° ë³´ì™„...")
            meta_result = ensure_metadata(folder, eng, kr, safety, dry_run)
            if meta_result['changes']:
                for c in meta_result['changes']:
                    print(f"     - {c}")
                stats['metadata_fixed'] += 1
            updates.append({'row': item['idx'], 'col': COL_METADATA, 'val': 'ì™„ë£Œ'})

        # 2. ìº¡ì…˜
        if item['p'] in ['-', ''] or item['q'] in ['-', '']:
            print(f"  ğŸ“ ìº¡ì…˜ ìƒì„±...")
            caption_result = ensure_captions(folder, eng, kr, safety, dry_run)
            if caption_result['created']:
                for c in caption_result['created']:
                    print(f"     - {c} ìƒì„±")
                stats['caption_created'] += 1
            if item['p'] in ['-', '']:
                updates.append({'row': item['idx'], 'col': COL_CAPTION_INSTA, 'val': 'ì™„ë£Œ'})
            if item['q'] in ['-', '']:
                updates.append({'row': item['idx'], 'col': COL_CAPTION_THREADS, 'val': 'ì™„ë£Œ'})

        # 3. Cloudinary
        if item['s'] in ['-', '']:
            print(f"  â˜ï¸ Cloudinary ì—…ë¡œë“œ...")
            cloud_result = upload_to_cloudinary(folder, num, eng, dry_run)
            if cloud_result['success'] or dry_run:
                print(f"     - {cloud_result.get('count', '?')}ê°œ ì´ë¯¸ì§€ ì—…ë¡œë“œ")
                stats['cloudinary_uploaded'] += 1
                updates.append({'row': item['idx'], 'col': COL_CLOUDINARY, 'val': 'ì™„ë£Œ'})
            else:
                print(f"     - ì‹¤íŒ¨: {cloud_result.get('error')}")
                stats['errors'].append(f"{num}: {cloud_result.get('error')}")
                updates.append({'row': item['idx'], 'col': COL_CLOUDINARY, 'val': 'ì‹¤íŒ¨'})

    # ì‹œíŠ¸ ì—…ë°ì´íŠ¸
    if updates and not dry_run:
        print(f"\n{'â”€'*60}")
        print(f"ğŸ“Š êµ¬ê¸€ì‹œíŠ¸ ì—…ë°ì´íŠ¸: {len(updates)}ê±´")
        cells = [gspread.Cell(u['row'], u['col'], u['val']) for u in updates]
        sheet.update_cells(cells)
        print("  âœ… ì—…ë°ì´íŠ¸ ì™„ë£Œ")
    elif dry_run:
        print(f"\n(dry-run ëª¨ë“œ: ì‹¤ì œ ì—…ë°ì´íŠ¸ ì—†ìŒ)")

    # ê²°ê³¼ ìš”ì•½
    print(f"\n{'='*70}")
    print("ğŸ“‹ ê²°ê³¼ ìš”ì•½")
    print(f"{'='*70}")
    print(f"  ì²˜ë¦¬ ëŒ€ìƒ: {len(incomplete)}ê±´")
    print(f"  ìº¡ì…˜ ìƒì„±: {stats['caption_created']}ê±´")
    print(f"  ë©”íƒ€ë°ì´í„° ìˆ˜ì •: {stats['metadata_fixed']}ê±´")
    print(f"  Cloudinary ì—…ë¡œë“œ: {stats['cloudinary_uploaded']}ê±´")
    if stats['errors']:
        print(f"  ì—ëŸ¬: {len(stats['errors'])}ê±´")
        for e in stats['errors'][:5]:
            print(f"    - {e}")

    return stats


def main():
    args = sys.argv[1:]

    if '--scan' in args:
        reconcile_all(scan_only=True)
    elif '--dry-run' in args:
        reconcile_all(dry_run=True)
    else:
        reconcile_all(dry_run=False)


if __name__ == "__main__":
    main()
